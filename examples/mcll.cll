(def mgenv (ref nil))

(defn mbind [ks vs env]
  (let { c (count ks) 
         k (fst ks)
         v (fst v) }
    (cond 
      (= c 0) env
      :else   (assoc k v (mbind (rst vs) (rst ks) env)))))

(defn mapply [op args env]
  (cond
    (function? op) 
      (call op args)
    :else 
      (let { p (:params op) 
             b (:body op) }
        (meval b (mbind p args env)))))
      
(defn meval-list [[op & args] env]
  (cond
    (= op 'def) (let { [k v] args }
      (set! mgenv (assoc k v @mgenv))
      (nil))
    (= op 'fn) (let { [p b] }
      { :params p :body b})
    :else (let { op   (meval op) 
                 args (map (fn [e] (meval e env)) args) }
            (mapply op args env))))

(defn meval [expr env]
  (println "expr: " expr " env: " env)
  (cond
    (symbol? expr) (get expr env)
    (list? expr)   (meval-list expr env)
    :else          expr
  )
)
