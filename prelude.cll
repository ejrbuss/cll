;; Macros
;; ------

(def defmacro (macro [name args & body]
  ~'(def ~name (macro ~args (do ~~body)))))

(defmacro defn [name args & body]
  ~'(def ~name (fn ~args (do ~~body))))

(defmacro comment [] nil)

(defmacro cond [& conds] 
  (if conds
    ~'(if ~(car conds) 
      ~(car (cdr conds)) 
      (cond ~~(cdr (cdr conds))))
    nil))

(defmacro for [e iter & body]
  ~'(reverse (reduce (fn [__for_0 ~e] 
    (cons (do
      ~~body) __for_0)) nil ~iter)))

(defmacro time-it [& body]
  ~'(let { __time_it_0 (time) }
    ~~body
    (let { __time_it_1 (time) }
      (- __time_it_1 __time_it_0))))

(defmacro assert [mode & args]
  (cond
    (= mode :true) (let { condition (car args) }
      ~'(if (not ~condition)
        (throw :Assertion-Error (str-fmt "Expected `{}`!" '~(car args)))))
    (= mode :false) (let { condition (car args) }
      ~'(if (not ~condition)
        (throw :Assertion-Error (str-fmt "Expected not `{}`!" '~(car args)))))
    (= mode :equal) (let { a (car args) b (car (cdr args)) }
      ~'(if (not (= ~a ~b))
        (throw :Assertion-Error (str-fmt "Expected `{}` to equal `{}`!" ~a ~b))))
    (= mode :not-equal) (let { a (car args) b (car (cdr args)) }
      ~'(if (= ~a ~b)
        (throw :Assertion-Error (str-fmt "Expected `{}` to equal `{}`!" ~a ~b))))
    :else (throw :Parameter-Error 
      (str-fmt "`assert` expected a mode (:true, :false, :equal) but received `{}`", mode))))

;; Docs

(def docs-dict (ref {}))

(defmacro defdoc [f docstr]
  (set! docs-dict (assoc f docstr @docs-dict)))

(defmacro doc [f]
  (if (in f @docs-dict)
    (println (@docs-dict f))
    (throw :Lookup-Error (str-fmt "No docs have been defined for `{}`!" f))))

;; Functions
;; ---------

;; Lists

(defn each [f iter]
  (let { ref-iter (ref iter) 
         ref-idx  (ref 0) }
    (while @ref-iter
      (f (car @ref-iter) @ref-idx)
      (set! ref-iter (cdr @ref-iter))
      (set! ref-idx (++ @ref-idx)))))

(defn reduce [f first iter]
  (let { r (ref first) }
    (each (fn [x] 
      (set! r (f @r x))) iter)
    @r))

(defn map [f iter]
  (let { r (ref nil) }
    (each (fn [x idx]
      (set! r (cons (f x idx) @r))) iter)
    (reverse @r)))

(defn filter [f iter]
  (let { r (ref nil) }
    (each (fn [x idx]
      (if (f x idx) 
        (set! r (cons x @r)))) iter)
    (reverse @r)))

(defn range [start end]
  (if (> start end)
    (throw :Parameter-Error "start must be less than end!")
    nil)
  (let { s (ref start)
         e (ref end) 
         l (ref nil) }
    (while (< @s @e)
      (set! l (cons @s @l))
      (set! s (++ @s)))
    (reverse @l)))

(defn concat [& lists]
  (if lists
    (if (cdr lists)
      (let { r    (ref nil)
             xs   (reverse (car lists))
             rest (call concat (cdr lists)) }
        (set! r rest)
        (each (fn [x] 
          (set! r (cons x @r))) xs)
        @r)
      (car lists))
  nil))

;; Functions

(defn curry [f & curried-args]
  (fn [& args]
    (call f (concat curried-args args))))

(defn apply! [f r]
  (set! r (f @r)))

;; Types

(defn reference? [o]
  (= (type-of o) :reference))

(defn symbol? [o]
  (= (type-of o) :symbol))

(defn keyword? [o]
  (= (type-of o) :keyword))

(defn string? [o]
  (= (type-of o) :string))

(defn number? [o]
  (= (type-of o) :number))

(defn list? [o]
  (= (type-of o) :list))

(defn dictionary? [o]
  (= (type-of o) :dictionary))

(defn macro? [o]
  (= (type-of o) :macro))

(defn function? [o]
  (= (type-of o) :function))

;; Math

(defn even? [n] 
  (= (mod n 2) 0))

(defn odd? [n]
  (not (even? n)))

(defn pos? [n]
  (> n 0))

(defn neg? [n]
  (< n 0))

(defn ++ [n]
  (+ n 1))

(defn -- [n]
  (- n 1))

;; Logical

(defn != [x y] 
  (not (= x y)))

(defn my-quote)
